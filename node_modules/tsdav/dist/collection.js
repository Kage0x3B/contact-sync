"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.smartCollectionSync = exports.syncCollection = exports.isCollectionDirty = exports.supportedReportSet = exports.makeCollection = exports.collectionQuery = void 0;
/* eslint-disable no-underscore-dangle */
const debug_1 = __importDefault(require("debug"));
const consts_1 = require("./consts");
const request_1 = require("./request");
const requestHelpers_1 = require("./util/requestHelpers");
const typeHelpers_1 = require("./util/typeHelpers");
const debug = debug_1.default('tsdav:collection');
const collectionQuery = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, body, depth, defaultNamespace = consts_1.DAVNamespace.DAV, headers } = params;
    return request_1.davRequest({
        url,
        init: {
            method: 'REPORT',
            headers: requestHelpers_1.cleanupFalsy(Object.assign(Object.assign({}, headers), { depth })),
            namespace: consts_1.DAVNamespaceShorthandMap[defaultNamespace],
            body,
        },
    });
});
exports.collectionQuery = collectionQuery;
const makeCollection = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, props, depth, headers } = params;
    return request_1.davRequest({
        url,
        init: {
            method: 'MKCOL',
            headers: requestHelpers_1.cleanupFalsy(Object.assign(Object.assign({}, headers), { depth })),
            namespace: consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.DAV],
            body: props
                ? {
                    mkcol: {
                        set: {
                            prop: requestHelpers_1.formatProps(props),
                        },
                    },
                }
                : undefined,
        },
    });
});
exports.makeCollection = makeCollection;
const supportedReportSet = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const { collection, headers } = params;
    const res = yield request_1.propfind({
        url: collection.url,
        props: [{ name: 'supported-report-set', namespace: consts_1.DAVNamespace.DAV }],
        depth: '1',
        headers,
    });
    return (_b = (_a = res[0]) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.supportedReportSet.supportedReport.map((sr) => Object.keys(sr.report)[0]);
});
exports.supportedReportSet = supportedReportSet;
const isCollectionDirty = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _c, _d;
    const { collection, headers } = params;
    const responses = yield request_1.propfind({
        url: collection.url,
        props: [{ name: 'getctag', namespace: consts_1.DAVNamespace.CALENDAR_SERVER }],
        depth: '0',
        headers,
    });
    const res = responses.filter((r) => requestHelpers_1.urlContains(collection.url, r.href))[0];
    if (!res) {
        throw new Error('Collection does not exist on server');
    }
    return { isDirty: collection.ctag !== ((_c = res.props) === null || _c === void 0 ? void 0 : _c.getctag), newCtag: (_d = res.props) === null || _d === void 0 ? void 0 : _d.getctag };
});
exports.isCollectionDirty = isCollectionDirty;
/**
 * This is for webdav sync-collection only
 */
const syncCollection = (params) => {
    const { url, props, headers, syncLevel, syncToken } = params;
    return request_1.davRequest({
        url,
        init: {
            method: 'REPORT',
            namespace: consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.DAV],
            headers: Object.assign({}, headers),
            body: {
                'sync-collection': {
                    _attributes: requestHelpers_1.getDAVAttribute([
                        consts_1.DAVNamespace.CALDAV,
                        consts_1.DAVNamespace.CARDDAV,
                        consts_1.DAVNamespace.DAV,
                    ]),
                    'sync-level': syncLevel,
                    'sync-token': syncToken,
                    [`${consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.DAV]}:prop`]: requestHelpers_1.formatProps(props),
                },
            },
        },
    });
};
exports.syncCollection = syncCollection;
/** remote collection to local */
const smartCollectionSync = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    const { collection, method, headers, account, detailedResult } = params;
    const requiredFields = ['accountType', 'homeUrl'];
    if (!account || !typeHelpers_1.hasFields(account, requiredFields)) {
        if (!account) {
            throw new Error('no account for smartCollectionSync');
        }
        throw new Error(`account must have ${typeHelpers_1.findMissingFieldNames(account, requiredFields)} before smartCollectionSync`);
    }
    const syncMethod = method !== null && method !== void 0 ? method : (((_e = collection.reports) === null || _e === void 0 ? void 0 : _e.includes('syncCollection')) ? 'webdav' : 'basic');
    debug(`smart collection sync with type ${account.accountType} and method ${syncMethod}`);
    if (syncMethod === 'webdav') {
        const result = yield exports.syncCollection({
            url: collection.url,
            props: [
                { name: 'getetag', namespace: consts_1.DAVNamespace.DAV },
                {
                    name: account.accountType === 'caldav' ? 'calendar-data' : 'address-data',
                    namespace: account.accountType === 'caldav' ? consts_1.DAVNamespace.CALDAV : consts_1.DAVNamespace.CARDDAV,
                },
                {
                    name: 'displayname',
                    namespace: consts_1.DAVNamespace.DAV,
                },
            ],
            syncLevel: 1,
            syncToken: collection.syncToken,
            headers,
        });
        const objectResponses = result.filter((r) => {
            var _a;
            const extName = account.accountType === 'caldav' ? '.ics' : '.vcf';
            return ((_a = r.href) === null || _a === void 0 ? void 0 : _a.slice(-4)) === extName;
        });
        const changedObjectUrls = objectResponses.filter((o) => o.status !== 404).map((r) => r.href);
        const deletedObjectUrls = objectResponses.filter((o) => o.status === 404).map((r) => r.href);
        const multiGetObjectResponse = changedObjectUrls.length
            ? (_g = (yield ((_f = collection === null || collection === void 0 ? void 0 : collection.objectMultiGet) === null || _f === void 0 ? void 0 : _f.call(collection, {
                url: collection.url,
                props: [
                    { name: 'getetag', namespace: consts_1.DAVNamespace.DAV },
                    {
                        name: account.accountType === 'caldav' ? 'calendar-data' : 'address-data',
                        namespace: account.accountType === 'caldav' ? consts_1.DAVNamespace.CALDAV : consts_1.DAVNamespace.CARDDAV,
                    },
                ],
                objectUrls: changedObjectUrls,
                depth: '1',
                headers,
            })))) !== null && _g !== void 0 ? _g : []
            : [];
        const remoteObjects = multiGetObjectResponse.map((res) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            return {
                url: (_a = res.href) !== null && _a !== void 0 ? _a : '',
                etag: (_b = res.props) === null || _b === void 0 ? void 0 : _b.getetag,
                data: (account === null || account === void 0 ? void 0 : account.accountType) === 'caldav'
                    ? (_e = (_d = (_c = res.props) === null || _c === void 0 ? void 0 : _c.calendarData) === null || _d === void 0 ? void 0 : _d._cdata) !== null && _e !== void 0 ? _e : (_f = res.props) === null || _f === void 0 ? void 0 : _f.calendarData
                    : (_j = (_h = (_g = res.props) === null || _g === void 0 ? void 0 : _g.addressData) === null || _h === void 0 ? void 0 : _h._cdata) !== null && _j !== void 0 ? _j : (_k = res.props) === null || _k === void 0 ? void 0 : _k.addressData,
            };
        });
        const localObjects = (_h = collection.objects) !== null && _h !== void 0 ? _h : [];
        // no existing url
        const created = remoteObjects.filter((o) => localObjects.every((lo) => !requestHelpers_1.urlContains(lo.url, o.url)));
        // debug(`created objects: ${created.map((o) => o.url).join('\n')}`);
        // have same url, but etag different
        const updated = localObjects.reduce((prev, curr) => {
            const found = remoteObjects.find((ro) => requestHelpers_1.urlContains(ro.url, curr.url));
            if (found && found.etag && found.etag !== curr.etag) {
                return [...prev, found];
            }
            return prev;
        }, []);
        // debug(`updated objects: ${updated.map((o) => o.url).join('\n')}`);
        const deleted = deletedObjectUrls.map((o) => ({
            url: o,
            etag: '',
        }));
        // debug(`deleted objects: ${deleted.map((o) => o.url).join('\n')}`);
        const unchanged = localObjects.filter((lo) => remoteObjects.some((ro) => requestHelpers_1.urlContains(lo.url, ro.url) && ro.etag === lo.etag));
        return Object.assign(Object.assign({}, collection), { objects: detailedResult
                ? { created, updated, deleted }
                : [...unchanged, ...created, ...updated], 
            // all syncToken in the results are the same so we use the first one here
            syncToken: (_m = (_l = (_k = (_j = result[0]) === null || _j === void 0 ? void 0 : _j.raw) === null || _k === void 0 ? void 0 : _k.multistatus) === null || _l === void 0 ? void 0 : _l.syncToken) !== null && _m !== void 0 ? _m : collection.syncToken });
    }
    if (syncMethod === 'basic') {
        const { isDirty, newCtag } = yield exports.isCollectionDirty({
            collection,
            headers,
        });
        const localObjects = (_o = collection.objects) !== null && _o !== void 0 ? _o : [];
        const remoteObjects = (_q = (yield ((_p = collection.fetchObjects) === null || _p === void 0 ? void 0 : _p.call(collection, { collection, headers })))) !== null && _q !== void 0 ? _q : [];
        // no existing url
        const created = remoteObjects.filter((ro) => localObjects.every((lo) => !requestHelpers_1.urlContains(lo.url, ro.url)));
        // debug(`created objects: ${created.map((o) => o.url).join('\n')}`);
        // have same url, but etag different
        const updated = localObjects.reduce((prev, curr) => {
            const found = remoteObjects.find((ro) => requestHelpers_1.urlContains(ro.url, curr.url));
            if (found && found.etag && found.etag !== curr.etag) {
                return [...prev, found];
            }
            return prev;
        }, []);
        // debug(`updated objects: ${updated.map((o) => o.url).join('\n')}`);
        // does not present in remote
        const deleted = localObjects.filter((cal) => remoteObjects.every((ro) => !requestHelpers_1.urlContains(ro.url, cal.url)));
        // debug(`deleted objects: ${deleted.map((o) => o.url).join('\n')}`);
        const unchanged = localObjects.filter((lo) => remoteObjects.some((ro) => requestHelpers_1.urlContains(lo.url, ro.url) && ro.etag === lo.etag));
        if (isDirty) {
            return Object.assign(Object.assign({}, collection), { objects: detailedResult
                    ? { created, updated, deleted }
                    : [...unchanged, ...created, ...updated], ctag: newCtag });
        }
    }
    return detailedResult
        ? Object.assign(Object.assign({}, collection), { objects: {
                created: [],
                updated: [],
                deleted: [],
            } }) : collection;
});
exports.smartCollectionSync = smartCollectionSync;
//# sourceMappingURL=collection.js.map