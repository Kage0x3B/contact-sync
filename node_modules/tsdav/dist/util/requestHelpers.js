"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanupFalsy = exports.formatFilters = exports.formatProps = exports.getDAVAttribute = exports.mergeObjectDupKeyArray = exports.urlContains = exports.urlEquals = void 0;
const consts_1 = require("../consts");
const urlEquals = (urlA, urlB) => {
    if (!urlA && !urlB) {
        return true;
    }
    if (!urlA || !urlB) {
        return false;
    }
    const trimmedUrlA = urlA.trim();
    const trimmedUrlB = urlB.trim();
    if (Math.abs(trimmedUrlA.length - trimmedUrlB.length) > 1) {
        return false;
    }
    const strippedUrlA = trimmedUrlA.slice(-1) === '/' ? trimmedUrlA.slice(0, -1) : trimmedUrlA;
    const strippedUrlB = trimmedUrlB.slice(-1) === '/' ? trimmedUrlB.slice(0, -1) : trimmedUrlB;
    return urlA.includes(strippedUrlB) || urlB.includes(strippedUrlA);
};
exports.urlEquals = urlEquals;
const urlContains = (urlA, urlB) => {
    if (!urlA && !urlB) {
        return true;
    }
    if (!urlA || !urlB) {
        return false;
    }
    const trimmedUrlA = urlA.trim();
    const trimmedUrlB = urlB.trim();
    const strippedUrlA = trimmedUrlA.slice(-1) === '/' ? trimmedUrlA.slice(0, -1) : trimmedUrlA;
    const strippedUrlB = trimmedUrlB.slice(-1) === '/' ? trimmedUrlB.slice(0, -1) : trimmedUrlB;
    return urlA.includes(strippedUrlB) || urlB.includes(strippedUrlA);
};
exports.urlContains = urlContains;
const mergeObjectDupKeyArray = (objA, objB) => {
    return Object.entries(objA).reduce((merged, [currKey, currValue]) => {
        if (merged[currKey] && Array.isArray(merged[currKey])) {
            // is array
            return Object.assign(Object.assign({}, merged), { [currKey]: [...merged[currKey], currValue] });
        }
        if (merged[currKey] && !Array.isArray(merged[currKey])) {
            // not array
            return Object.assign(Object.assign({}, merged), { [currKey]: [merged[currKey], currValue] });
        }
        // not exist
        return Object.assign(Object.assign({}, merged), { [currKey]: currValue });
    }, objB);
};
exports.mergeObjectDupKeyArray = mergeObjectDupKeyArray;
const getDAVAttribute = (nsArr) => nsArr.reduce((prev, curr) => (Object.assign(Object.assign({}, prev), { [consts_1.DAVAttributeMap[curr]]: curr })), {});
exports.getDAVAttribute = getDAVAttribute;
const formatProps = (props) => props === null || props === void 0 ? void 0 : props.reduce((prev, curr) => {
    var _a, _b;
    if (curr.namespace) {
        return Object.assign(Object.assign({}, prev), { [`${consts_1.DAVNamespaceShorthandMap[curr.namespace]}:${curr.name}`]: (_a = curr.value) !== null && _a !== void 0 ? _a : {} });
    }
    return Object.assign(Object.assign({}, prev), { [`${curr.name}`]: (_b = curr.value) !== null && _b !== void 0 ? _b : {} });
}, {});
exports.formatProps = formatProps;
const formatFilters = (filters) => filters === null || filters === void 0 ? void 0 : filters.map((f) => {
    var _a, _b;
    return ({
        [f.type]: Object.assign(Object.assign({ _attributes: f.attributes }, (_a = (f.children ? exports.formatFilters(f.children) : [])) === null || _a === void 0 ? void 0 : _a.reduce((prev, curr) => exports.mergeObjectDupKeyArray(prev, curr), {})), { _text: (_b = f.value) !== null && _b !== void 0 ? _b : '' }),
    });
});
exports.formatFilters = formatFilters;
const cleanupFalsy = (obj) => Object.entries(obj).reduce((prev, [key, value]) => {
    if (value)
        return Object.assign(Object.assign({}, prev), { [key]: value });
    return prev;
}, {});
exports.cleanupFalsy = cleanupFalsy;
//# sourceMappingURL=requestHelpers.js.map