"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteObject = exports.updateObject = exports.createObject = exports.propfind = exports.davRequest = void 0;
const cross_fetch_1 = require("cross-fetch");
const debug_1 = __importDefault(require("debug"));
const xml_js_1 = __importDefault(require("xml-js"));
const consts_1 = require("./consts");
const camelCase_1 = require("./util/camelCase");
const nativeType_1 = require("./util/nativeType");
const requestHelpers_1 = require("./util/requestHelpers");
const debug = debug_1.default('tsdav:request');
const davRequest = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { url, init, convertIncoming = true, parseOutgoing = true } = params;
    const { headers, body, namespace, method, attributes } = init;
    const xmlBody = convertIncoming
        ? xml_js_1.default.js2xml(Object.assign(Object.assign({}, body), { _attributes: attributes }), {
            compact: true,
            spaces: 2,
            elementNameFn: (name) => {
                // add namespace to all keys without namespace
                if (namespace && !/^.+:.+/.test(name)) {
                    return `${namespace}:${name}`;
                }
                return name;
            },
        })
        : body;
    // debug('outgoing xml:');
    // debug(xmlBody);
    const davResponse = yield cross_fetch_1.fetch(url, {
        headers: Object.assign({ 'Content-Type': 'text/xml;charset=UTF-8' }, requestHelpers_1.cleanupFalsy(headers)),
        body: xmlBody,
        method,
    });
    const resText = yield davResponse.text();
    // filter out invalid responses
    // debug('response xml:');
    // debug(resText);
    // debug(davResponse);
    if (!davResponse.ok ||
        !((_a = davResponse.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('xml')) ||
        !parseOutgoing) {
        return [
            {
                href: davResponse.url,
                ok: davResponse.ok,
                status: davResponse.status,
                statusText: davResponse.statusText,
                raw: resText,
            },
        ];
    }
    const result = xml_js_1.default.xml2js(resText, {
        compact: true,
        trim: true,
        textFn: (value, parentElement) => {
            try {
                // This is needed for xml-js design reasons
                // eslint-disable-next-line no-underscore-dangle
                const parentOfParent = parentElement._parent;
                const pOpKeys = Object.keys(parentOfParent);
                const keyNo = pOpKeys.length;
                const keyName = pOpKeys[keyNo - 1];
                const arrOfKey = parentOfParent[keyName];
                const arrOfKeyLen = arrOfKey.length;
                if (arrOfKeyLen > 0) {
                    const arr = arrOfKey;
                    const arrIndex = arrOfKey.length - 1;
                    arr[arrIndex] = nativeType_1.nativeType(value);
                }
                else {
                    parentOfParent[keyName] = nativeType_1.nativeType(value);
                }
            }
            catch (e) {
                debug(e.stack);
            }
        },
        // remove namespace & camelCase
        elementNameFn: (attributeName) => camelCase_1.camelCase(attributeName.replace(/^.+:/, '')),
        attributesFn: (value) => {
            const newVal = Object.assign({}, value);
            delete newVal.xmlns;
            return newVal;
        },
        ignoreDeclaration: true,
    });
    const responseBodies = Array.isArray(result.multistatus.response)
        ? result.multistatus.response
        : [result.multistatus.response];
    return responseBodies.map((responseBody) => {
        var _a, _b;
        const statusRegex = /^\S+\s(?<status>\d+)\s(?<statusText>.+)$/;
        if (!responseBody) {
            return {
                status: davResponse.status,
                statusText: davResponse.statusText,
                ok: davResponse.ok,
            };
        }
        const matchArr = statusRegex.exec(responseBody.status);
        return {
            raw: result,
            href: responseBody.href,
            status: (matchArr === null || matchArr === void 0 ? void 0 : matchArr.groups) ? Number.parseInt(matchArr === null || matchArr === void 0 ? void 0 : matchArr.groups.status, 10) : davResponse.status,
            statusText: (_b = (_a = matchArr === null || matchArr === void 0 ? void 0 : matchArr.groups) === null || _a === void 0 ? void 0 : _a.statusText) !== null && _b !== void 0 ? _b : davResponse.statusText,
            ok: !responseBody.error,
            error: responseBody.error,
            responsedescription: responseBody.responsedescription,
            props: (Array.isArray(responseBody.propstat)
                ? responseBody.propstat
                : [responseBody.propstat]).reduce((prev, curr) => {
                return Object.assign(Object.assign({}, prev), curr === null || curr === void 0 ? void 0 : curr.prop);
            }, {}),
        };
    });
});
exports.davRequest = davRequest;
const propfind = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, props, depth, headers } = params;
    return exports.davRequest({
        url,
        init: {
            method: 'PROPFIND',
            headers: requestHelpers_1.cleanupFalsy(Object.assign(Object.assign({}, headers), { depth })),
            namespace: consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.DAV],
            body: {
                propfind: {
                    _attributes: requestHelpers_1.getDAVAttribute([
                        consts_1.DAVNamespace.CALDAV,
                        consts_1.DAVNamespace.CALDAV_APPLE,
                        consts_1.DAVNamespace.CALENDAR_SERVER,
                        consts_1.DAVNamespace.CARDDAV,
                        consts_1.DAVNamespace.DAV,
                    ]),
                    prop: requestHelpers_1.formatProps(props),
                },
            },
        },
    });
});
exports.propfind = propfind;
const createObject = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, data, headers } = params;
    return cross_fetch_1.fetch(url, { method: 'PUT', body: data, headers });
});
exports.createObject = createObject;
const updateObject = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, data, etag, headers } = params;
    return cross_fetch_1.fetch(url, {
        method: 'PUT',
        body: data,
        headers: requestHelpers_1.cleanupFalsy(Object.assign(Object.assign({}, headers), { 'If-Match': etag })),
    });
});
exports.updateObject = updateObject;
const deleteObject = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, headers, etag } = params;
    return cross_fetch_1.fetch(url, {
        method: 'DELETE',
        headers: requestHelpers_1.cleanupFalsy(Object.assign(Object.assign({}, headers), { 'If-Match': etag })),
    });
});
exports.deleteObject = deleteObject;
//# sourceMappingURL=request.js.map