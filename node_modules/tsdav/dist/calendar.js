"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncCalendars = exports.deleteCalendarObject = exports.updateCalendarObject = exports.createCalendarObject = exports.fetchCalendarObjects = exports.fetchCalendars = exports.makeCalendar = exports.calendarMultiGet = exports.calendarQuery = void 0;
/* eslint-disable no-underscore-dangle */
const debug_1 = __importDefault(require("debug"));
const collection_1 = require("./collection");
const consts_1 = require("./consts");
const request_1 = require("./request");
const requestHelpers_1 = require("./util/requestHelpers");
const typeHelpers_1 = require("./util/typeHelpers");
const debug = debug_1.default('tsdav:calendar');
const calendarQuery = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, props, filters, timezone, depth, headers } = params;
    return collection_1.collectionQuery({
        url,
        body: {
            'calendar-query': {
                _attributes: requestHelpers_1.getDAVAttribute([
                    consts_1.DAVNamespace.CALDAV,
                    consts_1.DAVNamespace.CALENDAR_SERVER,
                    consts_1.DAVNamespace.CALDAV_APPLE,
                    consts_1.DAVNamespace.DAV,
                ]),
                [`${consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.DAV]}:prop`]: requestHelpers_1.formatProps(props),
                filter: requestHelpers_1.formatFilters(filters),
                timezone,
            },
        },
        defaultNamespace: consts_1.DAVNamespace.CALDAV,
        depth,
        headers,
    });
});
exports.calendarQuery = calendarQuery;
const calendarMultiGet = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, props, objectUrls, filters, timezone, depth, headers } = params;
    return collection_1.collectionQuery({
        url,
        body: {
            'calendar-multiget': {
                _attributes: requestHelpers_1.getDAVAttribute([consts_1.DAVNamespace.DAV, consts_1.DAVNamespace.CALDAV]),
                [`${consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.DAV]}:prop`]: requestHelpers_1.formatProps(props),
                [`${consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.DAV]}:href`]: objectUrls,
                filter: requestHelpers_1.formatFilters(filters),
                timezone,
            },
        },
        defaultNamespace: consts_1.DAVNamespace.CALDAV,
        depth,
        headers,
    });
});
exports.calendarMultiGet = calendarMultiGet;
const makeCalendar = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, props, depth, headers } = params;
    return request_1.davRequest({
        url,
        init: {
            method: 'MKCALENDAR',
            headers: requestHelpers_1.cleanupFalsy(Object.assign(Object.assign({}, headers), { depth })),
            namespace: consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.DAV],
            body: {
                [`${consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.CALDAV]}:mkcalendar`]: {
                    _attributes: requestHelpers_1.getDAVAttribute([consts_1.DAVNamespace.DAV, consts_1.DAVNamespace.CALDAV]),
                    set: {
                        prop: requestHelpers_1.formatProps(props),
                    },
                },
            },
        },
    });
});
exports.makeCalendar = makeCalendar;
const fetchCalendars = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { headers, account } = params !== null && params !== void 0 ? params : {};
    const requiredFields = ['homeUrl', 'rootUrl'];
    if (!account || !typeHelpers_1.hasFields(account, requiredFields)) {
        if (!account) {
            throw new Error('no account for fetchCalendars');
        }
        throw new Error(`account must have ${typeHelpers_1.findMissingFieldNames(account, requiredFields)} before fetchCalendars`);
    }
    const res = yield request_1.propfind({
        url: account.homeUrl,
        props: [
            { name: 'calendar-description', namespace: consts_1.DAVNamespace.CALDAV },
            { name: 'calendar-timezone', namespace: consts_1.DAVNamespace.CALDAV },
            { name: 'displayname', namespace: consts_1.DAVNamespace.DAV },
            { name: 'getctag', namespace: consts_1.DAVNamespace.CALENDAR_SERVER },
            { name: 'resourcetype', namespace: consts_1.DAVNamespace.DAV },
            { name: 'supported-calendar-component-set', namespace: consts_1.DAVNamespace.CALDAV },
            { name: 'sync-token', namespace: consts_1.DAVNamespace.DAV },
        ],
        depth: '1',
        headers,
    });
    return Promise.all(res
        .filter((r) => { var _a, _b; return Object.keys((_b = (_a = r.props) === null || _a === void 0 ? void 0 : _a.resourcetype) !== null && _b !== void 0 ? _b : {}).includes('calendar'); })
        .filter((rc) => {
        var _a, _b, _c;
        // filter out none iCal format calendars.
        const components = Array.isArray((_a = rc.props) === null || _a === void 0 ? void 0 : _a.supportedCalendarComponentSet.comp)
            ? (_b = rc.props) === null || _b === void 0 ? void 0 : _b.supportedCalendarComponentSet.comp.map((sc) => sc._attributes.name)
            : [(_c = rc.props) === null || _c === void 0 ? void 0 : _c.supportedCalendarComponentSet.comp._attributes.name] || [];
        return components.some((c) => Object.values(consts_1.ICALObjects).includes(c));
    })
        .map((rs) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        // debug(`Found calendar ${rs.props?.displayname}`);
        const description = (_a = rs.props) === null || _a === void 0 ? void 0 : _a.calendarDescription;
        const timezone = (_b = rs.props) === null || _b === void 0 ? void 0 : _b.calendarTimezon;
        return {
            description: typeof description === 'string' ? description : '',
            timezone: typeof timezone === 'string' ? timezone : '',
            url: new URL((_c = rs.href) !== null && _c !== void 0 ? _c : '', (_d = account.rootUrl) !== null && _d !== void 0 ? _d : '').href,
            ctag: (_e = rs.props) === null || _e === void 0 ? void 0 : _e.getctag,
            displayName: (_f = rs.props) === null || _f === void 0 ? void 0 : _f.displayname,
            components: Array.isArray((_g = rs.props) === null || _g === void 0 ? void 0 : _g.supportedCalendarComponentSet.comp)
                ? (_h = rs.props) === null || _h === void 0 ? void 0 : _h.supportedCalendarComponentSet.comp.map((sc) => sc._attributes.name)
                : [(_j = rs.props) === null || _j === void 0 ? void 0 : _j.supportedCalendarComponentSet.comp._attributes.name],
            resourcetype: Object.keys((_k = rs.props) === null || _k === void 0 ? void 0 : _k.resourcetype),
            syncToken: (_l = rs.props) === null || _l === void 0 ? void 0 : _l.syncToken,
        };
    })
        .map((cal) => __awaiter(void 0, void 0, void 0, function* () {
        return (Object.assign(Object.assign({}, cal), { reports: yield collection_1.supportedReportSet({ collection: cal, headers }) }));
    })));
});
exports.fetchCalendars = fetchCalendars;
const fetchCalendarObjects = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { calendar, objectUrls, filters: defaultFilters, timeRange, headers } = params;
    if (timeRange) {
        // validate timeRange
        const ISO_8601 = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?)?)?)?$/i;
        const ISO_8601_FULL = /^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;
        if ((!ISO_8601.test(timeRange.start) || !ISO_8601.test(timeRange.end)) &&
            (!ISO_8601_FULL.test(timeRange.start) || !ISO_8601_FULL.test(timeRange.end))) {
            throw new Error('invalid timeRange format, not in ISO8601');
        }
    }
    debug(`Fetching calendar objects from ${calendar === null || calendar === void 0 ? void 0 : calendar.url}`);
    const requiredFields = ['url'];
    if (!calendar || !typeHelpers_1.hasFields(calendar, requiredFields)) {
        if (!calendar) {
            throw new Error('cannot fetchCalendarObjects for undefined calendar');
        }
        throw new Error(`calendar must have ${typeHelpers_1.findMissingFieldNames(calendar, requiredFields)} before fetchCalendarObjects`);
    }
    // default to fetch all
    const filters = defaultFilters !== null && defaultFilters !== void 0 ? defaultFilters : [
        {
            type: 'comp-filter',
            attributes: { name: 'VCALENDAR' },
            children: [
                {
                    type: 'comp-filter',
                    attributes: { name: 'VEVENT' },
                    children: timeRange
                        ? [
                            {
                                type: 'time-range',
                                attributes: {
                                    start: new Date(timeRange.start).toISOString().replace(/[-:.]/g, ''),
                                    end: new Date(timeRange.end).toISOString().replace(/[-:.]/g, ''),
                                },
                            },
                        ]
                        : undefined,
                },
            ],
        },
    ];
    const calendarObjectUrls = (objectUrls !== null && objectUrls !== void 0 ? objectUrls : 
    // fetch all objects of the calendar
    (yield exports.calendarQuery({
        url: calendar.url,
        props: [{ name: 'getetag', namespace: consts_1.DAVNamespace.DAV }],
        filters,
        depth: '1',
        headers,
    })).map((res) => { var _a; return (_a = res.href) !== null && _a !== void 0 ? _a : ''; }))
        .map((url) => (url.startsWith('http') ? url : new URL(url, calendar.url).href)) // patch up to full url if url is not full
        .map((url) => new URL(url).pathname) // obtain pathname of the url
        .filter((url) => Boolean(url === null || url === void 0 ? void 0 : url.includes('.ics'))); // filter out non ics calendar objects since apple calendar might have those
    const calendarObjectResults = yield exports.calendarMultiGet({
        url: calendar.url,
        props: [
            { name: 'getetag', namespace: consts_1.DAVNamespace.DAV },
            { name: 'calendar-data', namespace: consts_1.DAVNamespace.CALDAV },
        ],
        objectUrls: calendarObjectUrls,
        depth: '1',
        headers,
    });
    return calendarObjectResults.map((res) => {
        var _a, _b, _c, _d, _e, _f;
        return ({
            url: new URL((_a = res.href) !== null && _a !== void 0 ? _a : '', calendar.url).href,
            etag: (_b = res.props) === null || _b === void 0 ? void 0 : _b.getetag,
            data: (_e = (_d = (_c = res.props) === null || _c === void 0 ? void 0 : _c.calendarData) === null || _d === void 0 ? void 0 : _d._cdata) !== null && _e !== void 0 ? _e : (_f = res.props) === null || _f === void 0 ? void 0 : _f.calendarData,
        });
    });
});
exports.fetchCalendarObjects = fetchCalendarObjects;
const createCalendarObject = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { calendar, iCalString, filename, headers } = params;
    return request_1.createObject({
        url: new URL(filename, calendar.url).href,
        data: iCalString,
        headers: Object.assign({ 'content-type': 'text/calendar; charset=utf-8' }, headers),
    });
});
exports.createCalendarObject = createCalendarObject;
const updateCalendarObject = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { calendarObject, headers } = params;
    return request_1.updateObject({
        url: calendarObject.url,
        data: calendarObject.data,
        etag: calendarObject.etag,
        headers: Object.assign({ 'content-type': 'text/calendar; charset=utf-8' }, headers),
    });
});
exports.updateCalendarObject = updateCalendarObject;
const deleteCalendarObject = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { calendarObject, headers } = params;
    return request_1.deleteObject({ url: calendarObject.url, etag: calendarObject.etag, headers });
});
exports.deleteCalendarObject = deleteCalendarObject;
/**
 * Sync remote calendars to local
 */
const syncCalendars = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { oldCalendars, account, detailedResult, headers } = params;
    if (!account) {
        throw new Error('Must have account before syncCalendars');
    }
    const localCalendars = (_a = oldCalendars !== null && oldCalendars !== void 0 ? oldCalendars : account.calendars) !== null && _a !== void 0 ? _a : [];
    const remoteCalendars = yield exports.fetchCalendars({ account, headers });
    // no existing url
    const created = remoteCalendars.filter((rc) => localCalendars.every((lc) => !requestHelpers_1.urlContains(lc.url, rc.url)));
    debug(`new calendars: ${created.map((cc) => cc.displayName)}`);
    // have same url, but syncToken/ctag different
    const updated = localCalendars.reduce((prev, curr) => {
        const found = remoteCalendars.find((rc) => requestHelpers_1.urlContains(rc.url, curr.url));
        if (found &&
            ((found.syncToken && found.syncToken !== curr.syncToken) ||
                (found.ctag && found.ctag !== curr.ctag))) {
            return [...prev, found];
        }
        return prev;
    }, []);
    debug(`updated calendars: ${updated.map((cc) => cc.displayName)}`);
    const updatedWithObjects = yield Promise.all(updated.map((u) => __awaiter(void 0, void 0, void 0, function* () {
        const result = yield collection_1.smartCollectionSync({
            collection: Object.assign(Object.assign({}, u), { objectMultiGet: exports.calendarMultiGet }),
            method: 'webdav',
            headers,
            account,
        });
        return result;
    })));
    // does not present in remote
    const deleted = localCalendars.filter((cal) => remoteCalendars.every((rc) => !requestHelpers_1.urlContains(rc.url, cal.url)));
    debug(`deleted calendars: ${deleted.map((cc) => cc.displayName)}`);
    const unchanged = localCalendars.filter((cal) => remoteCalendars.some((rc) => requestHelpers_1.urlContains(rc.url, cal.url) &&
        ((rc.syncToken && rc.syncToken !== cal.syncToken) || (rc.ctag && rc.ctag !== cal.ctag))));
    // debug(`unchanged calendars: ${unchanged.map((cc) => cc.displayName)}`);
    return detailedResult
        ? {
            created,
            updated,
            deleted,
        }
        : [...unchanged, ...created, ...updatedWithObjects];
});
exports.syncCalendars = syncCalendars;
//# sourceMappingURL=calendar.js.map