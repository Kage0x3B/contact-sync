"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteVCard = exports.updateVCard = exports.createVCard = exports.fetchVCards = exports.fetchAddressBooks = exports.addressBookMultiGet = exports.addressBookQuery = void 0;
/* eslint-disable no-underscore-dangle */
const debug_1 = __importDefault(require("debug"));
const collection_1 = require("./collection");
const consts_1 = require("./consts");
const request_1 = require("./request");
const requestHelpers_1 = require("./util/requestHelpers");
const typeHelpers_1 = require("./util/typeHelpers");
const debug = debug_1.default('tsdav:addressBook');
const addressBookQuery = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, props, depth, headers } = params;
    return collection_1.collectionQuery({
        url,
        body: {
            'addressbook-query': {
                _attributes: requestHelpers_1.getDAVAttribute([consts_1.DAVNamespace.CARDDAV, consts_1.DAVNamespace.DAV]),
                [`${consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.DAV]}:prop`]: requestHelpers_1.formatProps(props),
                filter: {
                    'prop-filter': {
                        _attributes: {
                            name: 'FN',
                        },
                    },
                },
            },
        },
        defaultNamespace: consts_1.DAVNamespace.CARDDAV,
        depth,
        headers,
    });
});
exports.addressBookQuery = addressBookQuery;
const addressBookMultiGet = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, props, objectUrls, filters, depth, headers } = params;
    return collection_1.collectionQuery({
        url,
        body: {
            'addressbook-multiget': {
                _attributes: requestHelpers_1.getDAVAttribute([consts_1.DAVNamespace.DAV, consts_1.DAVNamespace.CARDDAV]),
                [`${consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.DAV]}:prop`]: requestHelpers_1.formatProps(props),
                [`${consts_1.DAVNamespaceShorthandMap[consts_1.DAVNamespace.DAV]}:href`]: objectUrls,
                filter: requestHelpers_1.formatFilters(filters),
            },
        },
        defaultNamespace: consts_1.DAVNamespace.CARDDAV,
        depth,
        headers,
    });
});
exports.addressBookMultiGet = addressBookMultiGet;
const fetchAddressBooks = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { account, headers } = params !== null && params !== void 0 ? params : {};
    const requiredFields = ['homeUrl', 'rootUrl'];
    if (!account || !typeHelpers_1.hasFields(account, requiredFields)) {
        if (!account) {
            throw new Error('no account for fetchAddressBooks');
        }
        throw new Error(`account must have ${typeHelpers_1.findMissingFieldNames(account, requiredFields)} before fetchAddressBooks`);
    }
    const res = yield request_1.propfind({
        url: account.homeUrl,
        props: [
            { name: 'displayname', namespace: consts_1.DAVNamespace.DAV },
            { name: 'getctag', namespace: consts_1.DAVNamespace.CALENDAR_SERVER },
            { name: 'resourcetype', namespace: consts_1.DAVNamespace.DAV },
            { name: 'sync-token', namespace: consts_1.DAVNamespace.DAV },
        ],
        depth: '1',
        headers,
    });
    return Promise.all(res
        .filter((r) => { var _a, _b; return Object.keys((_b = (_a = r.props) === null || _a === void 0 ? void 0 : _a.resourcetype) !== null && _b !== void 0 ? _b : {}).includes('addressbook'); })
        .map((rs) => {
        var _a, _b, _c, _d, _e, _f;
        const displayName = (_a = rs.props) === null || _a === void 0 ? void 0 : _a.displayname;
        debug(`Found address book named ${typeof displayName === 'string' ? displayName : ''},
             props: ${JSON.stringify(rs.props)}`);
        return {
            url: new URL((_b = rs.href) !== null && _b !== void 0 ? _b : '', (_c = account.rootUrl) !== null && _c !== void 0 ? _c : '').href,
            ctag: (_d = rs.props) === null || _d === void 0 ? void 0 : _d.getctag,
            displayName: typeof displayName === 'string' ? displayName : '',
            resourcetype: Object.keys((_e = rs.props) === null || _e === void 0 ? void 0 : _e.resourcetype),
            syncToken: (_f = rs.props) === null || _f === void 0 ? void 0 : _f.syncToken,
        };
    })
        .map((addr) => __awaiter(void 0, void 0, void 0, function* () {
        return (Object.assign(Object.assign({}, addr), { reports: yield collection_1.supportedReportSet({ collection: addr, headers }) }));
    })));
});
exports.fetchAddressBooks = fetchAddressBooks;
const fetchVCards = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { addressBook, headers, objectUrls } = params;
    debug(`Fetching vcards from ${addressBook === null || addressBook === void 0 ? void 0 : addressBook.url}`);
    const requiredFields = ['url'];
    if (!addressBook || !typeHelpers_1.hasFields(addressBook, requiredFields)) {
        if (!addressBook) {
            throw new Error('cannot fetchVCards for undefined addressBook');
        }
        throw new Error(`addressBook must have ${typeHelpers_1.findMissingFieldNames(addressBook, requiredFields)} before fetchVCards`);
    }
    const vcardUrls = (objectUrls !== null && objectUrls !== void 0 ? objectUrls : 
    // fetch all objects of the calendar
    (yield exports.addressBookQuery({
        url: addressBook.url,
        props: [{ name: 'getetag', namespace: consts_1.DAVNamespace.DAV }],
        depth: '1',
        headers,
    })).map((res) => { var _a; return (_a = res.href) !== null && _a !== void 0 ? _a : ''; }))
        .map((url) => (url.includes('http') ? url : new URL(url, addressBook.url).href))
        .map((url) => new URL(url).pathname)
        .filter((url) => Boolean(url === null || url === void 0 ? void 0 : url.includes('.vcf')));
    const vCardResults = yield exports.addressBookMultiGet({
        url: addressBook.url,
        props: [
            { name: 'getetag', namespace: consts_1.DAVNamespace.DAV },
            { name: 'address-data', namespace: consts_1.DAVNamespace.CARDDAV },
        ],
        objectUrls: vcardUrls,
        depth: '1',
        headers,
    });
    return vCardResults.map((res) => {
        var _a, _b, _c, _d, _e, _f;
        return ({
            url: new URL((_a = res.href) !== null && _a !== void 0 ? _a : '', addressBook.url).href,
            etag: (_b = res.props) === null || _b === void 0 ? void 0 : _b.getetag,
            data: (_e = (_d = (_c = res.props) === null || _c === void 0 ? void 0 : _c.addressData) === null || _d === void 0 ? void 0 : _d._cdata) !== null && _e !== void 0 ? _e : (_f = res.props) === null || _f === void 0 ? void 0 : _f.addressData,
        });
    });
});
exports.fetchVCards = fetchVCards;
const createVCard = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { addressBook, vCardString, filename, headers } = params;
    return request_1.createObject({
        url: new URL(filename, addressBook.url).href,
        data: vCardString,
        headers: Object.assign({ 'content-type': 'text/vcard; charset=utf-8' }, headers),
    });
});
exports.createVCard = createVCard;
const updateVCard = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { vCard, headers } = params;
    return request_1.updateObject({
        url: vCard.url,
        data: vCard.data,
        etag: vCard.etag,
        headers: Object.assign({ 'content-type': 'text/vcard; charset=utf-8' }, headers),
    });
});
exports.updateVCard = updateVCard;
const deleteVCard = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { vCard, headers } = params;
    return request_1.deleteObject({
        url: vCard.url,
        etag: vCard.etag,
        headers,
    });
});
exports.deleteVCard = deleteVCard;
//# sourceMappingURL=addressBook.js.map