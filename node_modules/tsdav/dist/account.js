"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAccount = exports.fetchHomeUrl = exports.fetchPrincipalUrl = exports.serviceDiscovery = void 0;
const cross_fetch_1 = require("cross-fetch");
const debug_1 = __importDefault(require("debug"));
const addressBook_1 = require("./addressBook");
const calendar_1 = require("./calendar");
const consts_1 = require("./consts");
const request_1 = require("./request");
const requestHelpers_1 = require("./util/requestHelpers");
const typeHelpers_1 = require("./util/typeHelpers");
const debug = debug_1.default('tsdav:account');
const serviceDiscovery = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    debug('Service discovery...');
    const { account, headers } = params;
    const endpoint = new URL(account.serverUrl);
    const uri = new URL(`/.well-known/${account.accountType}`, endpoint);
    uri.protocol = (_a = endpoint.protocol) !== null && _a !== void 0 ? _a : 'http';
    try {
        const response = yield cross_fetch_1.fetch(uri.href, {
            headers,
            method: 'GET',
            redirect: 'manual',
        });
        if (response.status >= 300 && response.status < 400) {
            // http redirect.
            const location = response.headers.get('Location');
            if (typeof location === 'string' && location.length) {
                debug(`Service discovery redirected to ${location}`);
                const serviceURL = new URL(location, endpoint);
                serviceURL.protocol = (_b = endpoint.protocol) !== null && _b !== void 0 ? _b : 'http';
                return serviceURL.href;
            }
        }
    }
    catch (err) {
        debug(`Service discovery failed: ${err.stack}`);
    }
    return endpoint.href;
});
exports.serviceDiscovery = serviceDiscovery;
const fetchPrincipalUrl = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _c, _d, _e;
    const { account, headers } = params;
    const requiredFields = ['rootUrl'];
    if (!typeHelpers_1.hasFields(account, requiredFields)) {
        throw new Error(`account must have ${typeHelpers_1.findMissingFieldNames(account, requiredFields)} before fetchPrincipalUrl`);
    }
    debug(`Fetching principal url from path ${account.rootUrl}`);
    const [response] = yield request_1.propfind({
        url: account.rootUrl,
        props: [{ name: 'current-user-principal', namespace: consts_1.DAVNamespace.DAV }],
        depth: '0',
        headers,
    });
    if (!response.ok) {
        debug(`Fetch principal url failed: ${response.statusText}`);
        if (response.status === 401) {
            throw new Error('Invalid credentials');
        }
    }
    debug(`Fetched principal url ${(_c = response.props) === null || _c === void 0 ? void 0 : _c.currentUserPrincipal.href}`);
    return new URL((_e = (_d = response.props) === null || _d === void 0 ? void 0 : _d.currentUserPrincipal.href) !== null && _e !== void 0 ? _e : '', account.rootUrl).href;
});
exports.fetchPrincipalUrl = fetchPrincipalUrl;
const fetchHomeUrl = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _f, _g;
    const { account, headers } = params;
    const requiredFields = ['principalUrl', 'rootUrl'];
    if (!typeHelpers_1.hasFields(account, requiredFields)) {
        throw new Error(`account must have ${typeHelpers_1.findMissingFieldNames(account, requiredFields)} before fetchHomeUrl`);
    }
    debug(`Fetch home url from ${account.principalUrl}`);
    const responses = yield request_1.propfind({
        url: account.principalUrl,
        props: [
            account.accountType === 'caldav'
                ? { name: 'calendar-home-set', namespace: consts_1.DAVNamespace.CALDAV }
                : { name: 'addressbook-home-set', namespace: consts_1.DAVNamespace.CARDDAV },
        ],
        depth: '0',
        headers,
    });
    const matched = responses.find((r) => requestHelpers_1.urlContains(account.principalUrl, r.href));
    if (!matched || !matched.ok) {
        throw new Error('cannot find homeUrl');
    }
    const result = new URL(account.accountType === 'caldav'
        ? (_f = matched === null || matched === void 0 ? void 0 : matched.props) === null || _f === void 0 ? void 0 : _f.calendarHomeSet.href
        : (_g = matched === null || matched === void 0 ? void 0 : matched.props) === null || _g === void 0 ? void 0 : _g.addressbookHomeSet.href, account.rootUrl).href;
    debug(`Fetched home url ${result}`);
    return result;
});
exports.fetchHomeUrl = fetchHomeUrl;
const createAccount = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { account, headers, loadCollections = false, loadObjects = false } = params;
    const newAccount = Object.assign({}, account);
    newAccount.rootUrl = yield exports.serviceDiscovery({ account, headers });
    newAccount.principalUrl = yield exports.fetchPrincipalUrl({ account: newAccount, headers });
    newAccount.homeUrl = yield exports.fetchHomeUrl({ account: newAccount, headers });
    // to load objects you must first load collections
    if (loadCollections || loadObjects) {
        if (account.accountType === 'caldav') {
            newAccount.calendars = yield calendar_1.fetchCalendars({ headers, account: newAccount });
        }
        else if (account.accountType === 'carddav') {
            newAccount.addressBooks = yield addressBook_1.fetchAddressBooks({ headers, account: newAccount });
        }
    }
    if (loadObjects) {
        if (account.accountType === 'caldav' && newAccount.calendars) {
            newAccount.calendars = yield Promise.all(newAccount.calendars.map((cal) => __awaiter(void 0, void 0, void 0, function* () {
                return (Object.assign(Object.assign({}, cal), { objects: yield calendar_1.fetchCalendarObjects({ calendar: cal, headers }) }));
            })));
        }
        else if (account.accountType === 'carddav' && newAccount.addressBooks) {
            newAccount.addressBooks = yield Promise.all(newAccount.addressBooks.map((addr) => __awaiter(void 0, void 0, void 0, function* () {
                return (Object.assign(Object.assign({}, addr), { objects: yield addressBook_1.fetchVCards({ addressBook: addr, headers }) }));
            })));
        }
    }
    return newAccount;
});
exports.createAccount = createAccount;
//# sourceMappingURL=account.js.map