var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { fetch } from 'cross-fetch';
import getLogger from 'debug';
import convert from 'xml-js';
import { DAVNamespace, DAVNamespaceShorthandMap } from './consts';
import { camelCase } from './util/camelCase';
import { nativeType } from './util/nativeType';
import { cleanupFalsy, formatProps, getDAVAttribute } from './util/requestHelpers';
const debug = getLogger('tsdav:request');
export const davRequest = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { url, init, convertIncoming = true, parseOutgoing = true } = params;
    const { headers, body, namespace, method, attributes } = init;
    const xmlBody = convertIncoming
        ? convert.js2xml(Object.assign(Object.assign({}, body), { _attributes: attributes }), {
            compact: true,
            spaces: 2,
            elementNameFn: (name) => {
                // add namespace to all keys without namespace
                if (namespace && !/^.+:.+/.test(name)) {
                    return `${namespace}:${name}`;
                }
                return name;
            },
        })
        : body;
    // debug('outgoing xml:');
    // debug(xmlBody);
    const davResponse = yield fetch(url, {
        headers: Object.assign({ 'Content-Type': 'text/xml;charset=UTF-8' }, cleanupFalsy(headers)),
        body: xmlBody,
        method,
    });
    const resText = yield davResponse.text();
    // filter out invalid responses
    // debug('response xml:');
    // debug(resText);
    // debug(davResponse);
    if (!davResponse.ok ||
        !((_a = davResponse.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('xml')) ||
        !parseOutgoing) {
        return [
            {
                href: davResponse.url,
                ok: davResponse.ok,
                status: davResponse.status,
                statusText: davResponse.statusText,
                raw: resText,
            },
        ];
    }
    const result = convert.xml2js(resText, {
        compact: true,
        trim: true,
        textFn: (value, parentElement) => {
            try {
                // This is needed for xml-js design reasons
                // eslint-disable-next-line no-underscore-dangle
                const parentOfParent = parentElement._parent;
                const pOpKeys = Object.keys(parentOfParent);
                const keyNo = pOpKeys.length;
                const keyName = pOpKeys[keyNo - 1];
                const arrOfKey = parentOfParent[keyName];
                const arrOfKeyLen = arrOfKey.length;
                if (arrOfKeyLen > 0) {
                    const arr = arrOfKey;
                    const arrIndex = arrOfKey.length - 1;
                    arr[arrIndex] = nativeType(value);
                }
                else {
                    parentOfParent[keyName] = nativeType(value);
                }
            }
            catch (e) {
                debug(e.stack);
            }
        },
        // remove namespace & camelCase
        elementNameFn: (attributeName) => camelCase(attributeName.replace(/^.+:/, '')),
        attributesFn: (value) => {
            const newVal = Object.assign({}, value);
            delete newVal.xmlns;
            return newVal;
        },
        ignoreDeclaration: true,
    });
    const responseBodies = Array.isArray(result.multistatus.response)
        ? result.multistatus.response
        : [result.multistatus.response];
    return responseBodies.map((responseBody) => {
        var _a, _b;
        const statusRegex = /^\S+\s(?<status>\d+)\s(?<statusText>.+)$/;
        if (!responseBody) {
            return {
                status: davResponse.status,
                statusText: davResponse.statusText,
                ok: davResponse.ok,
            };
        }
        const matchArr = statusRegex.exec(responseBody.status);
        return {
            raw: result,
            href: responseBody.href,
            status: (matchArr === null || matchArr === void 0 ? void 0 : matchArr.groups) ? Number.parseInt(matchArr === null || matchArr === void 0 ? void 0 : matchArr.groups.status, 10) : davResponse.status,
            statusText: (_b = (_a = matchArr === null || matchArr === void 0 ? void 0 : matchArr.groups) === null || _a === void 0 ? void 0 : _a.statusText) !== null && _b !== void 0 ? _b : davResponse.statusText,
            ok: !responseBody.error,
            error: responseBody.error,
            responsedescription: responseBody.responsedescription,
            props: (Array.isArray(responseBody.propstat)
                ? responseBody.propstat
                : [responseBody.propstat]).reduce((prev, curr) => {
                return Object.assign(Object.assign({}, prev), curr === null || curr === void 0 ? void 0 : curr.prop);
            }, {}),
        };
    });
});
export const propfind = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, props, depth, headers } = params;
    return davRequest({
        url,
        init: {
            method: 'PROPFIND',
            headers: cleanupFalsy(Object.assign(Object.assign({}, headers), { depth })),
            namespace: DAVNamespaceShorthandMap[DAVNamespace.DAV],
            body: {
                propfind: {
                    _attributes: getDAVAttribute([
                        DAVNamespace.CALDAV,
                        DAVNamespace.CALDAV_APPLE,
                        DAVNamespace.CALENDAR_SERVER,
                        DAVNamespace.CARDDAV,
                        DAVNamespace.DAV,
                    ]),
                    prop: formatProps(props),
                },
            },
        },
    });
});
export const createObject = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, data, headers } = params;
    return fetch(url, { method: 'PUT', body: data, headers });
});
export const updateObject = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, data, etag, headers } = params;
    return fetch(url, {
        method: 'PUT',
        body: data,
        headers: cleanupFalsy(Object.assign(Object.assign({}, headers), { 'If-Match': etag })),
    });
});
export const deleteObject = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, headers, etag } = params;
    return fetch(url, {
        method: 'DELETE',
        headers: cleanupFalsy(Object.assign(Object.assign({}, headers), { 'If-Match': etag })),
    });
});
//# sourceMappingURL=request.js.map