var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { fetch } from 'cross-fetch';
import getLogger from 'debug';
import { fetchAddressBooks, fetchVCards } from './addressBook';
import { fetchCalendarObjects, fetchCalendars } from './calendar';
import { DAVNamespace } from './consts';
import { propfind } from './request';
import { urlContains } from './util/requestHelpers';
import { findMissingFieldNames, hasFields } from './util/typeHelpers';
const debug = getLogger('tsdav:account');
export const serviceDiscovery = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    debug('Service discovery...');
    const { account, headers } = params;
    const endpoint = new URL(account.serverUrl);
    const uri = new URL(`/.well-known/${account.accountType}`, endpoint);
    uri.protocol = (_a = endpoint.protocol) !== null && _a !== void 0 ? _a : 'http';
    try {
        const response = yield fetch(uri.href, {
            headers,
            method: 'GET',
            redirect: 'manual',
        });
        if (response.status >= 300 && response.status < 400) {
            // http redirect.
            const location = response.headers.get('Location');
            if (typeof location === 'string' && location.length) {
                debug(`Service discovery redirected to ${location}`);
                const serviceURL = new URL(location, endpoint);
                serviceURL.protocol = (_b = endpoint.protocol) !== null && _b !== void 0 ? _b : 'http';
                return serviceURL.href;
            }
        }
    }
    catch (err) {
        debug(`Service discovery failed: ${err.stack}`);
    }
    return endpoint.href;
});
export const fetchPrincipalUrl = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _c, _d, _e;
    const { account, headers } = params;
    const requiredFields = ['rootUrl'];
    if (!hasFields(account, requiredFields)) {
        throw new Error(`account must have ${findMissingFieldNames(account, requiredFields)} before fetchPrincipalUrl`);
    }
    debug(`Fetching principal url from path ${account.rootUrl}`);
    const [response] = yield propfind({
        url: account.rootUrl,
        props: [{ name: 'current-user-principal', namespace: DAVNamespace.DAV }],
        depth: '0',
        headers,
    });
    if (!response.ok) {
        debug(`Fetch principal url failed: ${response.statusText}`);
        if (response.status === 401) {
            throw new Error('Invalid credentials');
        }
    }
    debug(`Fetched principal url ${(_c = response.props) === null || _c === void 0 ? void 0 : _c.currentUserPrincipal.href}`);
    return new URL((_e = (_d = response.props) === null || _d === void 0 ? void 0 : _d.currentUserPrincipal.href) !== null && _e !== void 0 ? _e : '', account.rootUrl).href;
});
export const fetchHomeUrl = (params) => __awaiter(void 0, void 0, void 0, function* () {
    var _f, _g;
    const { account, headers } = params;
    const requiredFields = ['principalUrl', 'rootUrl'];
    if (!hasFields(account, requiredFields)) {
        throw new Error(`account must have ${findMissingFieldNames(account, requiredFields)} before fetchHomeUrl`);
    }
    debug(`Fetch home url from ${account.principalUrl}`);
    const responses = yield propfind({
        url: account.principalUrl,
        props: [
            account.accountType === 'caldav'
                ? { name: 'calendar-home-set', namespace: DAVNamespace.CALDAV }
                : { name: 'addressbook-home-set', namespace: DAVNamespace.CARDDAV },
        ],
        depth: '0',
        headers,
    });
    const matched = responses.find((r) => urlContains(account.principalUrl, r.href));
    if (!matched || !matched.ok) {
        throw new Error('cannot find homeUrl');
    }
    const result = new URL(account.accountType === 'caldav'
        ? (_f = matched === null || matched === void 0 ? void 0 : matched.props) === null || _f === void 0 ? void 0 : _f.calendarHomeSet.href
        : (_g = matched === null || matched === void 0 ? void 0 : matched.props) === null || _g === void 0 ? void 0 : _g.addressbookHomeSet.href, account.rootUrl).href;
    debug(`Fetched home url ${result}`);
    return result;
});
export const createAccount = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { account, headers, loadCollections = false, loadObjects = false } = params;
    const newAccount = Object.assign({}, account);
    newAccount.rootUrl = yield serviceDiscovery({ account, headers });
    newAccount.principalUrl = yield fetchPrincipalUrl({ account: newAccount, headers });
    newAccount.homeUrl = yield fetchHomeUrl({ account: newAccount, headers });
    // to load objects you must first load collections
    if (loadCollections || loadObjects) {
        if (account.accountType === 'caldav') {
            newAccount.calendars = yield fetchCalendars({ headers, account: newAccount });
        }
        else if (account.accountType === 'carddav') {
            newAccount.addressBooks = yield fetchAddressBooks({ headers, account: newAccount });
        }
    }
    if (loadObjects) {
        if (account.accountType === 'caldav' && newAccount.calendars) {
            newAccount.calendars = yield Promise.all(newAccount.calendars.map((cal) => __awaiter(void 0, void 0, void 0, function* () {
                return (Object.assign(Object.assign({}, cal), { objects: yield fetchCalendarObjects({ calendar: cal, headers }) }));
            })));
        }
        else if (account.accountType === 'carddav' && newAccount.addressBooks) {
            newAccount.addressBooks = yield Promise.all(newAccount.addressBooks.map((addr) => __awaiter(void 0, void 0, void 0, function* () {
                return (Object.assign(Object.assign({}, addr), { objects: yield fetchVCards({ addressBook: addr, headers }) }));
            })));
        }
    }
    return newAccount;
});
//# sourceMappingURL=account.js.map