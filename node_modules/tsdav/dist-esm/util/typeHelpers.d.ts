export declare type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;
export declare type NoUndefinedField<T> = {
    [P in keyof T]-?: NoUndefinedField<NonNullable<T[P]>>;
};
export declare type Await<T> = T extends PromiseLike<infer U> ? U : T;
export declare type ValueOf<T> = T[keyof T];
export declare type RequiredAndNotNull<T> = {
    [P in keyof T]-?: Exclude<T[P], null | undefined>;
};
export declare type RequireAndNotNullSome<T, K extends keyof T> = RequiredAndNotNull<Pick<T, K>> & Omit<T, K>;
export declare type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;
}[Keys];
export declare function hasFields<T, K extends keyof T>(obj: Array<T | RequireAndNotNullSome<T, K>>, fields: K[]): obj is Array<RequireAndNotNullSome<T, K>>;
export declare function hasFields<T, K extends keyof T>(obj: T | RequireAndNotNullSome<T, K>, fields: K[]): obj is RequireAndNotNullSome<T, K>;
export declare const findMissingFieldNames: <T>(obj: T, fields: (keyof T)[]) => string;
