var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable no-underscore-dangle */
import getLogger from 'debug';
import { collectionQuery, supportedReportSet } from './collection';
import { DAVNamespace, DAVNamespaceShorthandMap } from './consts';
import { createObject, deleteObject, propfind, updateObject } from './request';
import { formatFilters, formatProps, getDAVAttribute } from './util/requestHelpers';
import { findMissingFieldNames, hasFields } from './util/typeHelpers';
const debug = getLogger('tsdav:addressBook');
export const addressBookQuery = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, props, depth, headers } = params;
    return collectionQuery({
        url,
        body: {
            'addressbook-query': {
                _attributes: getDAVAttribute([DAVNamespace.CARDDAV, DAVNamespace.DAV]),
                [`${DAVNamespaceShorthandMap[DAVNamespace.DAV]}:prop`]: formatProps(props),
                filter: {
                    'prop-filter': {
                        _attributes: {
                            name: 'FN',
                        },
                    },
                },
            },
        },
        defaultNamespace: DAVNamespace.CARDDAV,
        depth,
        headers,
    });
});
export const addressBookMultiGet = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { url, props, objectUrls, filters, depth, headers } = params;
    return collectionQuery({
        url,
        body: {
            'addressbook-multiget': {
                _attributes: getDAVAttribute([DAVNamespace.DAV, DAVNamespace.CARDDAV]),
                [`${DAVNamespaceShorthandMap[DAVNamespace.DAV]}:prop`]: formatProps(props),
                [`${DAVNamespaceShorthandMap[DAVNamespace.DAV]}:href`]: objectUrls,
                filter: formatFilters(filters),
            },
        },
        defaultNamespace: DAVNamespace.CARDDAV,
        depth,
        headers,
    });
});
export const fetchAddressBooks = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { account, headers } = params !== null && params !== void 0 ? params : {};
    const requiredFields = ['homeUrl', 'rootUrl'];
    if (!account || !hasFields(account, requiredFields)) {
        if (!account) {
            throw new Error('no account for fetchAddressBooks');
        }
        throw new Error(`account must have ${findMissingFieldNames(account, requiredFields)} before fetchAddressBooks`);
    }
    const res = yield propfind({
        url: account.homeUrl,
        props: [
            { name: 'displayname', namespace: DAVNamespace.DAV },
            { name: 'getctag', namespace: DAVNamespace.CALENDAR_SERVER },
            { name: 'resourcetype', namespace: DAVNamespace.DAV },
            { name: 'sync-token', namespace: DAVNamespace.DAV },
        ],
        depth: '1',
        headers,
    });
    return Promise.all(res
        .filter((r) => { var _a, _b; return Object.keys((_b = (_a = r.props) === null || _a === void 0 ? void 0 : _a.resourcetype) !== null && _b !== void 0 ? _b : {}).includes('addressbook'); })
        .map((rs) => {
        var _a, _b, _c, _d, _e, _f;
        const displayName = (_a = rs.props) === null || _a === void 0 ? void 0 : _a.displayname;
        debug(`Found address book named ${typeof displayName === 'string' ? displayName : ''},
             props: ${JSON.stringify(rs.props)}`);
        return {
            url: new URL((_b = rs.href) !== null && _b !== void 0 ? _b : '', (_c = account.rootUrl) !== null && _c !== void 0 ? _c : '').href,
            ctag: (_d = rs.props) === null || _d === void 0 ? void 0 : _d.getctag,
            displayName: typeof displayName === 'string' ? displayName : '',
            resourcetype: Object.keys((_e = rs.props) === null || _e === void 0 ? void 0 : _e.resourcetype),
            syncToken: (_f = rs.props) === null || _f === void 0 ? void 0 : _f.syncToken,
        };
    })
        .map((addr) => __awaiter(void 0, void 0, void 0, function* () {
        return (Object.assign(Object.assign({}, addr), { reports: yield supportedReportSet({ collection: addr, headers }) }));
    })));
});
export const fetchVCards = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { addressBook, headers, objectUrls } = params;
    debug(`Fetching vcards from ${addressBook === null || addressBook === void 0 ? void 0 : addressBook.url}`);
    const requiredFields = ['url'];
    if (!addressBook || !hasFields(addressBook, requiredFields)) {
        if (!addressBook) {
            throw new Error('cannot fetchVCards for undefined addressBook');
        }
        throw new Error(`addressBook must have ${findMissingFieldNames(addressBook, requiredFields)} before fetchVCards`);
    }
    const vcardUrls = (objectUrls !== null && objectUrls !== void 0 ? objectUrls : 
    // fetch all objects of the calendar
    (yield addressBookQuery({
        url: addressBook.url,
        props: [{ name: 'getetag', namespace: DAVNamespace.DAV }],
        depth: '1',
        headers,
    })).map((res) => { var _a; return (_a = res.href) !== null && _a !== void 0 ? _a : ''; }))
        .map((url) => (url.includes('http') ? url : new URL(url, addressBook.url).href))
        .map((url) => new URL(url).pathname)
        .filter((url) => Boolean(url === null || url === void 0 ? void 0 : url.includes('.vcf')));
    const vCardResults = yield addressBookMultiGet({
        url: addressBook.url,
        props: [
            { name: 'getetag', namespace: DAVNamespace.DAV },
            { name: 'address-data', namespace: DAVNamespace.CARDDAV },
        ],
        objectUrls: vcardUrls,
        depth: '1',
        headers,
    });
    return vCardResults.map((res) => {
        var _a, _b, _c, _d, _e, _f;
        return ({
            url: new URL((_a = res.href) !== null && _a !== void 0 ? _a : '', addressBook.url).href,
            etag: (_b = res.props) === null || _b === void 0 ? void 0 : _b.getetag,
            data: (_e = (_d = (_c = res.props) === null || _c === void 0 ? void 0 : _c.addressData) === null || _d === void 0 ? void 0 : _d._cdata) !== null && _e !== void 0 ? _e : (_f = res.props) === null || _f === void 0 ? void 0 : _f.addressData,
        });
    });
});
export const createVCard = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { addressBook, vCardString, filename, headers } = params;
    return createObject({
        url: new URL(filename, addressBook.url).href,
        data: vCardString,
        headers: Object.assign({ 'content-type': 'text/vcard; charset=utf-8' }, headers),
    });
});
export const updateVCard = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { vCard, headers } = params;
    return updateObject({
        url: vCard.url,
        data: vCard.data,
        etag: vCard.etag,
        headers: Object.assign({ 'content-type': 'text/vcard; charset=utf-8' }, headers),
    });
});
export const deleteVCard = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { vCard, headers } = params;
    return deleteObject({
        url: vCard.url,
        etag: vCard.etag,
        headers,
    });
});
//# sourceMappingURL=addressBook.js.map